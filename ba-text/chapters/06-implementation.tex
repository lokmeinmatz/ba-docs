% !TeX root = ../thesis_main.tex

% ---------------------------------------------------
% ----- Chapters of the template
% ----- for Bachelor-, Master thesis and class papers
% ---------------------------------------------------
%  Created by C. Müller-Birn on 2012-08-17, CC-BY-SA 3.0.
%  Freie Universität Berlin, Institute of Computer Science, Human Centered Computing. 
%
% TODO remove 2 - to use auto numbering
\section{Implementation and deployment}
\label{chap:chapters} 

The phase of implementation and deployment followed an agile development process, where I could deploy changes easily to get fast feedback from users.
I strucutured the chapter into the follwoign parts:

(TEMPORARY, use latex subchapter list?)
\begin{itemize}
  \item Software stack
  \item CI/CD
  \item Security (Protocols and audits)
  \item Scalability
  \item Automated Testing
  \item User Testing, Internal Beta and Monitoring
  \item Communication and Documentation
\end{itemize}

\subsection{Software stack}

A common point appearing in brownfield software projects, or generally in larger companies and software ecosystems, is the limitation in technologies that should be used for a new project.
Else, one may chose the latest and greatest language or framework for that usecase, but maintainability and availability of persons to review and collaborate are important as well.
To reduce overhead of learning new languages, tech stacks and keeping the infrastrucuture manageble, often a small set of languages and frameworks is provided by the
devops- or infrastructure team. In my case, the most important point was the availability of additional persons with knowledge. The contraints from devops side were not that tight,
since the code gets deployed in Kubernetes, a containerized environment anyways, so as long as it can run on a linux VM, it could get deployed.
\\
In the end, I decided to use Typescript (\url{https://www.typescriptlang.org}) on both back- and frontend.
The advantages are wide availability of persons who also work with it, a mature ecosystem, and shared type declarations between server and client,
reducing the risk of creating incompatabile data instances by accident.

The rest of the stack is fairly common in the web developemnt industry as well, the frontend uses React JS as a rendering and reactivity framework,
with additional libraries for state management, UI Components and API query management on top.

For the backend, I used Node as a Javascript runtime, combined with the most used HTTP server framework for Node, Express JS \cite{Github:VanoDevium/node-framework-stars}

asd